/* @flow */
import _ from 'underscore'
import invariant from 'invariant'
import matches from './pattern_match'

export const BLOCKED_ERROR: Error = new Error('attempt to receive while blocking')

type MsgT = any
type ContinuationFunctionT = () => void
type ActionFunctionT = (msg: MsgT) => void

type MatchObjectT = {match: MsgT, action: ActionFunctionT}
type MatchObectsT = Array<MatchObjectT>

// globally registered actors
const _actorsRegister = {}

var cntxtCounter = 1
type ContextT = {id: number, blocking: boolean, timer: ?number, ms: ?MatchObectsT, continuation: ?ContinuationFunctionT}

export const TIME_OUT: string = '1234567_TIMEOUT'
export const DOWN: string = '1234567_DOWN'
export const EXIT: string = '1234567_EXIT'

type SignalT = {name: '1234567_EXIT', pid: *, reason: string}

const IMMEDIATE_TIMEOUT = -1

function tempReportError(e) {
  console.error(e)
}

export default class BadActor2 {
  _cntxStack: Array<ContextT>
  _inbox: Array<MsgT>
  _savedMsgs: Array<MsgT>
  _monitors: Array<BadActor2>
  _links: Array<BadActor2>
  _trapExit: boolean
  DEAD: boolean

  resetState(): void {
    this._cntxStack = []
    this._inbox = []
    this._savedMsgs = []
    this._monitors = []
    this._links = []
    this._trapExit = false
  }

  constructor(moduleInit: (actor: BadActor2, ...initArgs?: any) => void, ...initArgs?: any) {
    this.resetState()
    moduleInit(this, ...initArgs)
    // if the module init function didn't block (kinda pointless but not necessarily illegal) we're done so kill us
    if (!this.DEAD && this._cntxStack.length === 0) this._killObject('normal')
  }

  trapExit(flag: boolean): void {
    if (this.DEAD) return
    this._trapExit = flag
  }

  link(actor: BadActor2): void {
    if (this.DEAD) return
    invariant(actor && actor !== this, 'dont link to null or self')
    if (!_.contains(actor._links, this)) actor._links.push(this) // ugh this needs an accessor
    if (!_.contains(this._links, actor)) this._links.push(actor)
  }

  monitor(actor: BadActor2): void {
    if (this.DEAD) return
    invariant(actor && actor !== this, 'dont link to null or self')
    actor._monitors.push(this) // ugh this needs an accessor
  }

  signal(msg: SignalT): void {
    if (this.DEAD) return
    switch (msg.name) {
      case EXIT:
        if (this._trapExit) {
          this.sendMsg(msg)
        } else {
          if (msg.reason !== 'normal') this._killObject(msg.reason)
        }
        break
    }
  }

  sendMsg(msg: MsgT): void {
    if (this.DEAD) return
    if (msg === TIME_OUT) throw new Error('timeout is private')
    this._inbox.push(msg)
    if (this._cntxStack.length && this._cntxStack[this._cntxStack.length - 1]['blocking']) {
      try {
        this._popAndDoLastContextOnStack()
      } catch (e) {
        // this protects the caller, but how to kill the object?
        this._killObject(e.message)
      }
    }
  }

  _tryOrDie(callback: Function, optArg?: *): boolean {
    try {
      callback(optArg)
      return true
    } catch (e) {
      this._killObject(e.message)
      tempReportError(e)
      return false
    }
  }

  _performAction(actionf: Function, msg: MsgT): boolean {
    return this._tryOrDie(actionf, msg)
  }

  _performContinuation(continuef: Function): boolean {
    return this._tryOrDie(continuef)
  }

  _unwindCntxtStack(): boolean {
    for (let i = this._cntxStack.length; i > 0; i--) {
      var cntxt = this._cntxStack.pop()
      invariant(cntxt.ms, 'ms should be here')
      invariant(cntxt.continuation, 'this should be here')
      invariant(cntxt['timer'] === IMMEDIATE_TIMEOUT || cntxt['timer'] == null, 'timeout config error')
      if (cntxt['timer'] === IMMEDIATE_TIMEOUT) {
        const timeOutObject = _.find(cntxt.ms, function(matchObject) { return matchObject.match === TIME_OUT })
        if (timeOutObject) {
          let shouldContinue = this._performAction(timeOutObject['action'], null)
          if (!shouldContinue) {
            return false
          }
        }
      }
      let shouldContinue = this._performContinuation(cntxt.continuation)
      if (!shouldContinue) return false
    }
    return true
  }

  _unwindAndExitIfBottom() {
    let empty = this._unwindCntxtStack()
    if (empty) {
      this._killObject('normal')
    }
  }

  _killObject(reason: string): void {
    _.chain(_actorsRegister).pick((v) => (v === this)).keys().each((v) => { unregister(v) })

    this.DEAD = true
    for (let i = 0; i < this._cntxStack.length; i++) {
      let cntxt = this._cntxStack[i]
      cntxt.ms = null
      cntxt.continuation = null
      if (cntxt['timer'] && cntxt['timer'] !== IMMEDIATE_TIMEOUT) {
        clearTimeout(cntxt['timer'])
        cntxt['timer'] = null
      }
    }
    this._monitors.forEach((monitor) => {
      monitor.sendMsg({name: DOWN, pid: this, reason: reason})
    })
    this._links.forEach((linked) => {
      linked._links = _.without(linked._links, this)
      const msg: SignalT = {name: '1234567_EXIT', pid: this, reason: reason}
      linked.signal(msg)
    })
    this.resetState()
  }

  _blocking(): boolean {
    return !!this._cntxStack.length && (this._cntxStack[this._cntxStack.length - 1]['blocking'] === true)
  }

  _timeoutCallback(timer: number) {
    invariant(this._cntxStack.length > 0 && this._cntxStack[this._cntxStack.length - 1]['blocking'], 'did we forget to clear the timer or something')
    const cntxt: ContextT = _.last(this._cntxStack)
    invariant(cntxt['timer'] === timer, 'did we mess up the timer?')
    invariant(cntxt.ms, 'timer would have been cleared if we had been killed')
    const timeOutms = _.find(cntxt.ms, function(matchObject) { return matchObject.match === TIME_OUT })
    invariant(timeOutms, 'if  passed a timeout value, you must add a timeout clause')
    cntxt['timer'] = null
    let shouldContinue = this._performAction(timeOutms['action'], null)
    if (!shouldContinue) {
      return
    }
    this._unwindAndExitIfBottom()
  }

  _newTimer(timeout: number): number {
    if (timeout === 0) return IMMEDIATE_TIMEOUT
    const timer = setTimeout(() => {
      this._timeoutCallback(timer)
    }, timeout)
    return timer
  }

  // makes a new context and pushes it onto the stack
  RECEIVE(matchStatementObjects: MatchObectsT, continuation: ContinuationFunctionT, maybeTimeout: ?number): void {
    if (this.DEAD) return
    if (_.chain(this._cntxStack).pluck('blocking').contains(true).value()) {
      throw BLOCKED_ERROR
    }
    invariant((matchStatementObjects && continuation), 'arg error')
    const timer = maybeTimeout == null ? null : this._newTimer(maybeTimeout)
    const cntxt: ContextT = {id: cntxtCounter++, blocking: false, timer: timer, ms: matchStatementObjects, continuation: continuation}
    this._cntxStack.push(cntxt)
    this._popAndDoLastContextOnStack()
  }

  // indexOfCurrentCntx is how it works, cant remember why
  attemptMatch(msg: MsgT, matchStatementObject: MatchObjectT, indexOfCurrentCntx: number): string {
    const matchResult: boolean = matches(matchStatementObject['match'], msg)
    if (matchResult) {
      this._inbox = [...this._savedMsgs, ...this._inbox] // put save queue back, in the right order (the order they arrived) eek they need an index
      this._savedMsgs = []
      const cntxt = this._cntxStack[indexOfCurrentCntx]
      if (cntxt['timer'] /* && cntxt['timer'] !== IMMEDIATE_TIMEOUT */) {
        clearTimeout(cntxt['timer'])
        cntxt['timer'] = null
      }
      // shit! the inner receive can be blocking, in which case don't do the continuation
      invariant(!cntxt['blocking'], 'blocking sanity check')
      if (!this._performAction(matchStatementObject['action'], msg)) return 'exit'

      if ((this._cntxStack.length > (indexOfCurrentCntx + 1)) && this._cntxStack[this._cntxStack.length - 1]['blocking']) {
        return 'innerblocking'
      } else {
        this._unwindAndExitIfBottom()
        return 'ok'
      }
    } else {
      return 'no_match'
    }
  }

  _popAndDoLastContextOnStack() {
    const indexOfCurrentCntx = this._cntxStack.length - 1
    const cntxt = this._cntxStack[indexOfCurrentCntx]
    invariant(cntxt.ms && cntxt.ms.length, 'must have this')
    invariant(cntxt.continuation, 'must have this')
    const matchStatementObjects = cntxt.ms
    const inboxclone: Array<MsgT> = this._inbox.slice(0)
    cntxt['blocking'] = false
    for (let inboxPtr = 0; inboxPtr < inboxclone.length; inboxPtr++) {
      const msg = inboxclone[inboxPtr]
      this._inbox.shift()
      for (let matchStatementPtr = 0; matchStatementPtr < matchStatementObjects.length; matchStatementPtr++) {
        const matchStatementObject = matchStatementObjects[matchStatementPtr]
        // timeout clause is handled seperately
        // temp, this is only going to work while we have simple string matching
        if (matchStatementObject['match'] === TIME_OUT) continue
        switch (this.attemptMatch(msg, matchStatementObject, indexOfCurrentCntx)) {
          case 'no_match':
            this._savedMsgs.push(msg)
            break
          case 'exit':
          case 'innerblocking':
          case 'ok':
            return
          default:
            // continue
        }
      }
    }
    if (cntxt['timer'] === IMMEDIATE_TIMEOUT) {
      this._unwindAndExitIfBottom()
    } else {
      // we are now blocking, what does this mean? No more receives can be called on this pid, etc.
      cntxt['blocking'] = true
    }
  }
}

// Not sure if we need Pids or just register the actor
export function register(name: string, actor: BadActor2): void {
  if (_actorsRegister[name] && _actorsRegister[name] !== actor) throw new Error('another actor already registered as ' + name)
  _actorsRegister[name] = actor
}

export function unregister(name: string): void {
  if (!_actorsRegister[name]) throw new Error('cant unregister actor ' + name)
  delete _actorsRegister[name]
}

export function sendMsg(name: string, msg: MsgT): void {
  _actorsRegister[name].sendMsg(msg)
}

export function registered(): Array<string> {
  return (_.keys(_.pick(_actorsRegister, _.identity)))
}

// passing the name around and calling whereis on it is a race bacause of restarting. Erlang adds unique refs to messages
// type PidT = number
// function whereis(name): PidT | null {}
