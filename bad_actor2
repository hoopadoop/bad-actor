/* @flow */
import _ from 'underscore'
import invariant from 'invariant'

export const BLOCKED_ERROR: Error = new Error('attempt to receive while blocking')

type MsgT = any
type ContinuationFunctionT = () => void
type ActionFunctionT = (msg: MsgT) => void

type MatchObjectT = {match: MsgT, action: ActionFunctionT}
type MatchObectsT = Array<MatchObjectT>

// globally registered actors
const _actorsRegister = {}

var cntxtCounter = 1
type ContextT = {id: number, blocking: boolean, timer: ?number, ms: ?MatchObectsT, continuation: ?ContinuationFunctionT}

export const TIME_OUT: string = '1234567_TIMEOUT'
export const DOWN: string = '1234567_DOWN'
export const EXIT: string = '1234567_EXIT'

type Exit1T = {name: '1234567_EXIT'}
type Exit2T = {name: 'not yet needed'}
type SignalT = Exit1T | Exit2T

const IMMEDIATE_TIMEOUT = -1

function tempReportError(e) {
  console.error(e)
}

// nicked from underscore and crippled by me, dont copy this as a general purpose deep equels
function matches(pattern: MsgT, msg: MsgT, aStack, bStack): boolean {
  if (pattern === '*') return true
  if (pattern === msg) return pattern !== 0 || 1 / pattern === 1 / msg
  if (pattern == null || msg == null) return pattern === msg
  const className = toString.call(pattern)
  if (className !== toString.call(msg)) return false
  switch (className) {
    case '[object RegExp]':
    case '[object String]':
      return '' + pattern === '' + msg
    case '[object Number]':
      if (+pattern !== +pattern) return +msg !== +msg
      return +pattern === 0 ? 1 / +pattern === 1 / msg : +pattern === +msg
    case '[object Date]':
    case '[object Boolean]':
      return +pattern === +msg
  }
  var areArrays = className === '[object Array]'
  if (!areArrays) {
    if (typeof pattern !== 'object' || typeof msg !== 'object') return false
    const aCtor = pattern.constructor
    const bCtor = msg.constructor
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && ('constructor' in pattern && 'constructor' in msg)) {
      return false
    }
  }
  aStack = aStack || []
  bStack = bStack || []
  var length = aStack.length
  while (length--) {
    if (aStack[length] === pattern) return bStack[length] === msg
  }
  aStack.push(pattern)
  bStack.push(msg)
  if (areArrays) {
    length = pattern.length
    if (length !== msg.length) return false
    while (length--) {
      if (!matches(pattern[length], msg[length], aStack, bStack)) return false
    }
  } else {
    var keys = _.keys(pattern)
    var key
    length = keys.length
    if (_.keys(msg).length !== length) return false
    while (length--) {
      key = keys[length]
      if (!(_.has(msg, key) && matches(pattern[key], msg[key], aStack, bStack))) return false
    }
  }
  aStack.pop()
  bStack.pop()
  return true
}

export default class BadActor2 {
  _cntxStack: Array<ContextT>
  _inbox: Array<MsgT>
  _savedMsgs: Array<MsgT>
  _monitors: Array<BadActor2>
  _links: Array<BadActor2>
  _trapExit: boolean
  DEAD: boolean

  resetState(): void {
    this._cntxStack = []
    this._inbox = []
    this._savedMsgs = []
    this._monitors = []
    this._links = []
    this._trapExit = false
  }

  constructor(moduleInit: (actor: BadActor2, ...initArgs?: any) => void, ...initArgs?: any) {
    this.resetState()
    moduleInit(this, ...initArgs)
    // if the module init function didn't block (kinda pointless but not necessarily illegal) we're done so kill us
    if (!this.DEAD && this._cntxStack.length === 0) this._killObject()
  }

  trapExit(flag: boolean): void {
    if (this.DEAD) return
    this._trapExit = flag
  }

  link(actor: BadActor2): void {
    if (this.DEAD) return
    invariant(actor && actor !== this, 'dont link to null or self')
    if (!_.contains(actor._links, this)) actor._links.push(this) // ugh this needs an accessor
    if (!_.contains(this._links, actor)) this._links.push(actor)
  }

  monitor(actor: BadActor2): void {
    if (this.DEAD) return
    invariant(actor && actor !== this, 'dont link to null or self')
    actor._monitors.push(this) // ugh this needs an accessor
  }

  signal(msg: SignalT): void {
    if (this.DEAD) return
    switch (msg.name) {
      case EXIT:
        if (this._trapExit) {
          this.sendMsg(EXIT)
        } else {
          this._killObject()
        }
        break
    }
  }

  sendMsg(msg: MsgT): void {
    if (this.DEAD) return
    if (msg === TIME_OUT) throw new Error('timeout is private')
    this._inbox.push(msg)
    if (this._cntxStack.length && this._cntxStack[this._cntxStack.length - 1]['blocking']) {
      try {
        this.RECEIVE(null, null)
      } catch (e) {
        // this protects the caller, but how to kill the object?
        this._killObject()
      }
    }
  }

  _performAction(actionf: Function, msg: MsgT): boolean {
    try {
      actionf(msg)
      return true
    } catch (e) {
      this._killObject()
      tempReportError(e)
      return false
    }
  }

  _performContinuation(continuef: Function): boolean {
    try {
      continuef()
      return true
    } catch (e) {
      this._killObject()
      tempReportError(e)
      return false
    }
  }

  _unwindCntxtStack(): boolean {
    for (let i = this._cntxStack.length; i > 0; i--) {
      var cntxt = this._cntxStack.pop()
      invariant(cntxt.ms, 'ms should be here')
      invariant(cntxt.continuation, 'this should be here')
      invariant(cntxt['timer'] === IMMEDIATE_TIMEOUT || cntxt['timer'] == null, 'timeout config error')
      if (cntxt['timer'] === IMMEDIATE_TIMEOUT) {
        const timeOutObject = _.find(cntxt.ms, function(matchObject) { return matchObject.match === TIME_OUT })
        if (timeOutObject) {
          let shouldContinue = this._performAction(timeOutObject['action'], null)
          if (!shouldContinue) {
            return false
          }
        }
      }
      let shouldContinue = this._performContinuation(cntxt.continuation)
      if (!shouldContinue) return false
    }
    return true
  }

  _killObject(): void {
    _.chain(_actorsRegister).pick((v) => (v === this)).keys().each((v) => { unregister(v) })

    this.DEAD = true
    for (let i = 0; i < this._cntxStack.length; i++) {
      let cntxt = this._cntxStack[i]
      cntxt.ms = null
      cntxt.continuation = null
      if (cntxt['timer'] && cntxt['timer'] !== IMMEDIATE_TIMEOUT) {
        clearTimeout(cntxt['timer'])
        cntxt['timer'] = null
      }
    }
    this._monitors.forEach((monitor) => {
      monitor.sendMsg(DOWN)
    })
    this._links.forEach((linked) => {
      linked._links = _.without(linked._links, this)
      const msg: SignalT = {name: '1234567_EXIT'}
      linked.signal(msg)
    })
    this.resetState()
  }

  _blocking(): boolean {
    return !!this._cntxStack.length && (this._cntxStack[this._cntxStack.length - 1]['blocking'] === true)
  }

  RECEIVE(maybeMatchStatementObjects: ?MatchObectsT, maybeContinuation: ?ContinuationFunctionT, maybeTimeout: ?number): void {
    if (this.DEAD) return
    invariant((maybeMatchStatementObjects && maybeContinuation) || (!maybeMatchStatementObjects && !maybeContinuation), 'arg error')
    let cntxt: ContextT
    let matchStatementObjects: MatchObectsT
    let continuation: ContinuationFunctionT

    if (maybeMatchStatementObjects && maybeContinuation) {
      // this is a call not a retry, make a new context
      matchStatementObjects = maybeMatchStatementObjects
      continuation = maybeContinuation
      if (_.chain(this._cntxStack).pluck('blocking').contains(true).value()) {
        throw BLOCKED_ERROR
      }
      cntxt = {id: cntxtCounter++, blocking: false, timer: null, ms: matchStatementObjects, continuation: continuation}
      let timer = null
      if (maybeTimeout === 0) {
        timer = IMMEDIATE_TIMEOUT
      } else if (maybeTimeout && maybeTimeout > 0) {
        timer = setTimeout(() => {
          if (cntxt['timer'] === timer) {
            cntxt['timer'] = null
            invariant(cntxt.ms, 'timer would have been cleared if we had been killed')
            invariant(this._cntxStack.length > 0 && this._cntxStack[this._cntxStack.length - 1]['blocking'], 'did we forget to clear the timer or something')
            const timeOutObject = _.find(cntxt.ms, function(matchObject) {
              return matchObject.match === TIME_OUT
            })
            invariant(timeOutObject, 'if you passed a timeout value, you must add a timeout clause')
            try {
              let shouldContinue = this._performAction(timeOutObject['action'], null)
              if (!shouldContinue) {
                return
              }

              let empty = this._unwindCntxtStack()
              if (empty) {
                this._killObject()
              }
            } catch (e) {
              this._killObject()
            }
          } else { throw new Error('did we mess up the timer?') }
        }, maybeTimeout)
      }

      cntxt['timer'] = timer
      this._cntxStack.push(cntxt)
    } else {
      // no matches were passed in, we want to retry the top of the stack
      cntxt = this._cntxStack[this._cntxStack.length - 1]
      invariant(cntxt && cntxt['blocking'], 'we are only retrying blocking receives')
      invariant(cntxt.ms, 'must have this')
      invariant(cntxt.continuation, 'must have this')
      matchStatementObjects = cntxt.ms
      continuation = cntxt.continuation
      cntxt['blocking'] = false
    }
    const indexOfCurrentCntx = this._cntxStack.length - 1
    const inboxclone: Array<MsgT> = this._inbox.slice(0)
    for (let inboxPtr = 0; inboxPtr < inboxclone.length; inboxPtr++) {
      const msg = inboxclone[inboxPtr]
      this._inbox.shift()
      for (let matchStatementPtr = 0; matchStatementPtr < matchStatementObjects.length; matchStatementPtr++) {
        const matchStatementObject = matchStatementObjects[matchStatementPtr]

        // timeout clause is handled seperately
        // temp, this is only going to work while we have simple string matching
        if (matchStatementObject['match'] === TIME_OUT) continue

        const matchResult: boolean = matches(matchStatementObject['match'], msg)
        if (matchResult) {
          this._inbox = [...this._savedMsgs, ...this._inbox] // put save queue back, in the right order (the order they arrived) eek they need an index
          this._savedMsgs = []
          if (cntxt['timer'] /* && cntxt['timer'] !== IMMEDIATE_TIMEOUT */) {
            clearTimeout(cntxt['timer'])
            cntxt['timer'] = null
          }
          // shit! the inner receive can be blocking, in which case don't do the continuation
          invariant(!cntxt['blocking'], 'blocking sanity check')
          let shouldContinue = this._performAction(matchStatementObject['action'], msg)
          if (!shouldContinue) {
            return
          }
          const innerDidFailToMatchAndIsBlocking: boolean = (this._cntxStack.length > (indexOfCurrentCntx + 1)) && this._cntxStack[this._cntxStack.length - 1]['blocking']
          if (innerDidFailToMatchAndIsBlocking) {
            // the inner context is blocking, not us
            return
          } else {
            let empty = this._unwindCntxtStack()
            if (empty) {
              this._killObject()
            }
            return
          }
        } else {
          this._savedMsgs.push(msg)
        }
      }
    }

    if (cntxt['timer'] === IMMEDIATE_TIMEOUT) {
      let empty = this._unwindCntxtStack()
      if (empty) {
        this._killObject()
      }
    } else {
      // we are now blocking, what does this mean? No more receives can be called on this pid, etc.
      cntxt['blocking'] = true
    }
  }
}

// Not sure if we need Pids or just register the actor
export function register(name: string, actor: BadActor2): void {
  if (_actorsRegister[name] && _actorsRegister[name] !== actor) throw new Error('another actor already registered as ' + name)
  _actorsRegister[name] = actor
}

export function unregister(name: string): void {
  if (!_actorsRegister[name]) throw new Error('cant unregister actor ' + name)
  delete _actorsRegister[name]
}

export function sendMsg(name: string, msg: MsgT): void {
  _actorsRegister[name].sendMsg(msg)
}

export function registered(): Array<string> {
  return (_.keys(_.pick(_actorsRegister, _.identity)))
}

// passing the name around and calling whereis on it is a race bacause of restarting. Erlang adds unique refs to messages
// type PidT = number
// function whereis(name): PidT | null {}
